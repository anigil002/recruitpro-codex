"""Lightweight AI helpers with deterministic fallbacks."""

from datetime import datetime
from random import randint
from typing import Any, Dict, List

from .activity import log_activity
from ..models import AIJob, Candidate, Project, ScreeningRun
from ..utils.security import generate_id


def enqueue_ai_job(session, job_type: str, **kwargs) -> AIJob:
    job = AIJob(
        job_id=generate_id(),
        job_type=job_type,
        project_id=kwargs.get("project_id"),
        position_id=kwargs.get("position_id"),
        candidate_id=kwargs.get("candidate_id"),
        status="completed",
        request_json=kwargs.get("request"),
        response_json=kwargs.get("response"),
        created_at=datetime.utcnow(),
        updated_at=datetime.utcnow(),
    )
    session.add(job)
    return job


def analyze_file_stub(file_name: str) -> Dict[str, Any]:
    return {
        "project_info": {
            "name": None,
            "summary": None,
            "sector": None,
            "location_region": None,
            "client": None,
        },
        "positions": [
            {
                "title": file_name.replace(".txt", "").replace(".pdf", "").title(),
                "department": None,
                "experience": None,
                "responsibilities": ["Review provided documentation"],
                "requirements": ["Experience with RecruitPro"],
                "location": None,
                "description": None,
            }
        ],
        "file_diagnostics": {
            "type": "txt",
            "positions_detected": 1,
            "project_info_detected": False,
        },
    }


def generate_jd_stub(title: str) -> Dict[str, Any]:
    return {
        "description": f"Autogenerated JD for {title}.",
        "responsibilities": [
            "Collaborate with the recruitment team to deliver hiring goals.",
            "Maintain accurate records in RecruitPro.",
        ],
        "requirements": [
            "2+ years of relevant experience",
            "Strong communication skills",
        ],
        "nice_to_have": ["Familiarity with AI-assisted sourcing"],
    }


def generate_email_stub(payload: Dict[str, Any]) -> Dict[str, str]:
    title = payload.get("title") or payload.get("role") or "Role"
    candidate = payload.get("candidate_name", "Candidate")
    subject = f"Opportunity: {title}"
    body = (
        f"Hi {candidate},\n\n"
        f"We're working on a role for {title} that aligns with your background. "
        f"Let's schedule a quick chat to explore fit.\n\n"
        "Best regards,\nRecruitPro Team"
    )
    return {"subject": subject, "body": body}


def generate_call_script_stub(payload: Dict[str, Any]) -> Dict[str, Any]:
    title = payload.get("title", "the role")
    candidate = payload.get("candidate_name", "there")
    value_props = payload.get("value_props", [])
    return {
        "opening": f"Hi {candidate}, thanks for taking the call about {title}.",
        "qualify": [
            "Could you walk me through your recent projects?",
            "What drew your attention to opportunities like this?",
        ],
        "value_props": value_props or ["Impactful project", "Collaborative team"],
        "objections": [
            {"concern": "I'm busy", "response": "We can work around your schedule for next steps."}
        ],
        "closing": "Thanks againâ€”I'll follow up with next steps after syncing with the team.",
    }


def generate_salary_stub(payload: Dict[str, Any]) -> Dict[str, Any]:
    base = randint(60000, 80000)
    return {
        "currency": "USD",
        "annual_min": base,
        "annual_mid": base + 10000,
        "annual_max": base + 20000,
        "rationale": "Range derived from internal benchmarking dataset.",
        "sources": [
            {"title": "RecruitPro Insights", "url": "https://recruitpro.local/benchmarks"}
        ],
    }


def record_screening(session, candidate: Candidate, position_id: str, score: Dict[str, Any]) -> ScreeningRun:
    run = ScreeningRun(
        screening_id=generate_id(),
        candidate_id=candidate.candidate_id,
        position_id=position_id,
        score_json=score,
        created_at=datetime.utcnow(),
    )
    session.add(run)
    return run
