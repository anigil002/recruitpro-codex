<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RecruitPro Local Console</title>
    <style>
      :root {
        color-scheme: dark light;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        --bg: #0f172a;
        --panel: #111a22;
        --panel-border: #1e2a3a;
        --accent: #3b82f6;
        --accent-soft: #60a5fa;
        --text: #e2e8f0;
        --muted: #94a3b8;
        --success: #22c55e;
        --error: #ef4444;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg);
        color: var(--text);
        display: flex;
        justify-content: center;
        padding: 40px 16px;
      }

      a {
        color: var(--accent);
      }

      h1,
      h2,
      h3 {
        margin: 0;
        font-weight: 600;
      }

      p {
        margin: 0;
      }

      .shell {
        width: min(1200px, 100%);
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 14px;
        padding: 24px;
        box-shadow: 0 20px 45px -20px rgba(17, 115, 212, 0.25);
      }

      .panel + .panel {
        margin-top: 0;
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        margin-bottom: 16px;
      }

      .grid-two {
        display: grid;
        gap: 16px;
      }

      .grid-three {
        display: grid;
        gap: 16px;
      }

      @media (min-width: 960px) {
        .grid-two {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
        .grid-three {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 16px;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      input,
      select,
      textarea {
        font: inherit;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--panel-border);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
      }

      textarea {
        min-height: 80px;
        resize: vertical;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 10px 16px;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
        background: var(--accent);
        color: #0f172a;
        align-self: flex-start;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px -12px rgba(96, 165, 250, 0.6);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .muted {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .messages {
        border-radius: 12px;
        padding: 14px 18px;
        display: none;
        line-height: 1.4;
      }

      .messages[data-state="visible"] {
        display: block;
      }

      .messages[data-variant="success"] {
        background: rgba(34, 197, 94, 0.12);
        border: 1px solid rgba(34, 197, 94, 0.35);
        color: var(--success);
      }

      .messages[data-variant="error"] {
        background: rgba(239, 68, 68, 0.12);
        border: 1px solid rgba(239, 68, 68, 0.35);
        color: var(--error);
      }

      .messages[data-variant="info"] {
        background: rgba(96, 165, 250, 0.12);
        border: 1px solid rgba(96, 165, 250, 0.35);
        color: var(--accent-soft);
      }

      .stat-grid {
        display: grid;
        gap: 16px;
      }

      @media (min-width: 768px) {
        .stat-grid {
          grid-template-columns: repeat(4, minmax(0, 1fr));
        }
      }

      .stat-card {
        border-radius: 12px;
        border: 1px solid var(--panel-border);
        background: rgba(15, 23, 42, 0.65);
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .stat-card strong {
        font-size: 2rem;
        font-weight: 700;
      }

      .item-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .item-card {
        border-radius: 12px;
        border: 1px solid var(--panel-border);
        background: rgba(15, 23, 42, 0.55);
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .item-card h4 {
        margin: 0;
        font-size: 1.05rem;
      }

      .empty-state {
        padding: 18px;
        border-radius: 12px;
        border: 1px dashed var(--panel-border);
        background: rgba(15, 23, 42, 0.4);
        color: var(--muted);
        text-align: center;
      }

      .actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 0.8rem;
        background: rgba(59, 130, 246, 0.18);
        border: 1px solid rgba(59, 130, 246, 0.4);
        color: var(--accent-soft);
      }

      .hidden {
        display: none !important;
      }

      .subpanel {
        margin-top: 32px;
        padding-top: 24px;
        border-top: 1px solid var(--panel-border);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .result-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 12px;
      }

      .result-card {
        border-radius: 10px;
        border: 1px solid var(--panel-border);
        background: rgba(15, 23, 42, 0.45);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .result-card h5 {
        margin: 0;
        font-size: 0.95rem;
      }

      .result-card a {
        align-self: flex-start;
      }

      .text-error {
        color: var(--error);
        font-size: 0.9rem;
      }

      .text-success {
        color: var(--success);
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <header class="panel">
        <div class="panel-header">
          <div>
            <h1>RecruitPro Local Console</h1>
            <p class="muted">
              Register, sign in, and manage projects, positions, and candidates powered by the FastAPI backend.
            </p>
          </div>
          <button id="refresh-button" type="button">Refresh data</button>
        </div>
        <p class="muted" style="margin-top: 4px;">
          The console talks directly to the REST API. All numbers below reflect the live SQLite database on your machine.
        </p>
      </header>

      <div class="messages" id="messages" role="status" aria-live="polite"></div>

      <section class="panel" id="auth-panel">
        <h2>Get started locally</h2>
        <p class="muted" style="margin-top: 8px;">
          Create an account for local testing or sign in with an existing RecruitPro user. Passwords never leave your machine.
        </p>
        <div class="grid-two" style="margin-top: 24px;">
          <form id="register-form">
            <h3>Create account</h3>
            <label>
              Name
              <input name="name" type="text" autocomplete="name" required />
            </label>
            <label>
              Email
              <input name="email" type="email" autocomplete="email" required />
            </label>
            <label>
              Password
              <input name="password" type="password" autocomplete="new-password" minlength="8" required />
            </label>
            <label>
              Role
              <select name="role">
                <option value="recruiter">Recruiter</option>
                <option value="admin">Admin</option>
              </select>
            </label>
            <button type="submit">Register</button>
            <p class="muted">The account is stored in SQLite and can be reused when you return.</p>
          </form>

          <form id="login-form">
            <h3>Sign in</h3>
            <label>
              Email
              <input name="email" type="email" autocomplete="email" required />
            </label>
            <label>
              Password
              <input name="password" type="password" autocomplete="current-password" required />
            </label>
            <button type="submit">Log in</button>
            <p class="muted">Successful login stores a token in your browser for reuse.</p>
          </form>
        </div>
      </section>

      <section class="panel hidden" id="app-panel">
        <div class="panel-header">
          <div>
            <h2>Workspace</h2>
            <p class="muted" id="workspace-user">Signed in as â€”</p>
          </div>
          <div class="actions">
            <span class="badge" id="workspace-role"></span>
            <button id="logout-button" type="button">Log out</button>
          </div>
        </div>

        <div class="stat-grid" style="margin-bottom: 32px;">
          <article class="stat-card">
            <span class="muted">Projects</span>
            <strong id="stat-projects">0</strong>
          </article>
          <article class="stat-card">
            <span class="muted">Positions</span>
            <strong id="stat-positions">0</strong>
          </article>
          <article class="stat-card">
            <span class="muted">Open positions</span>
            <strong id="stat-open-positions">0</strong>
          </article>
          <article class="stat-card">
            <span class="muted">Candidates</span>
            <strong id="stat-candidates">0</strong>
          </article>
        </div>

        <div class="grid-three">
          <section>
            <h3>Projects</h3>
            <p class="muted" style="margin-top: 4px;">Manage client workstreams and define hiring goals.</p>
            <ul class="item-list" id="projects-list"></ul>
            <form id="project-form" autocomplete="off">
              <h4>Create project</h4>
              <label>
                Project name
                <input name="name" type="text" required />
              </label>
              <label>
                Client name
                <input name="client" type="text" />
              </label>
              <label>
                Region / Location
                <input name="location_region" type="text" />
              </label>
              <label>
                Summary
                <textarea name="summary" placeholder="Short internal description"></textarea>
              </label>
              <label>
                Tags (comma separated)
                <input name="tags" type="text" placeholder="fintech, remote, senior" />
              </label>
              <label>
                Team members (comma separated)
                <input name="team_members" type="text" placeholder="alex@example.com, taylor@example.com" />
              </label>
              <label>
                Target hires
                <input name="target_hires" type="number" min="0" step="1" />
              </label>
              <button type="submit">Save project</button>
            </form>
            <form id="document-upload-form" autocomplete="off">
              <h4>Upload project document</h4>
              <label>
                Project
                <select id="document-project" name="project_id" disabled required></select>
              </label>
              <label>
                File
                <input id="document-file" name="file" type="file" accept=".pdf,.doc,.docx,.txt,.md,.csv,.xlsx,.pptx,.json,.rtf" required />
              </label>
              <p class="muted">Upload project briefs, scorecards, or other hiring collateral to kick off AI analysis.</p>
              <button type="submit" disabled>Upload document</button>
            </form>
          </section>

          <section>
            <h3>Positions</h3>
            <p class="muted" style="margin-top: 4px;">Attach open roles to each project to track headcount.</p>
            <ul class="item-list" id="positions-list"></ul>
            <form id="position-form" autocomplete="off">
              <h4>Create position</h4>
              <label>
                Project
                <select id="position-project" name="project_id" required></select>
              </label>
              <label>
                Title
                <input name="title" type="text" required />
              </label>
              <label>
                Department
                <input name="department" type="text" />
              </label>
              <label>
                Location
                <input name="location" type="text" />
              </label>
              <label>
                Status
                <select name="status">
                  <option value="draft">Draft</option>
                  <option value="open">Open</option>
                  <option value="closed">Closed</option>
                </select>
              </label>
              <label>
                Openings
                <input name="openings" type="number" min="0" step="1" />
              </label>
              <label>
                Responsibilities (one per line)
                <textarea name="responsibilities" placeholder="Define interview loop\nPartner with hiring manager"></textarea>
              </label>
              <label>
                Requirements (one per line)
                <textarea name="requirements" placeholder="5+ years exp\nExperience with SaaS"></textarea>
              </label>
              <button type="submit">Save position</button>
            </form>
          </section>

          <section>
            <h3>Candidates</h3>
            <p class="muted" style="margin-top: 4px;">Track talent pipeline and jump into detailed profiles.</p>
            <ul class="item-list" id="candidates-list"></ul>
            <form id="candidate-form" autocomplete="off">
              <h4>Add candidate</h4>
              <label>
                Full name
                <input name="name" type="text" required />
              </label>
              <label>
                Source
                <input name="source" type="text" placeholder="LinkedIn, Referralâ€¦" required />
              </label>
              <label>
                Email
                <input name="email" type="email" />
              </label>
              <label>
                Project (optional)
                <select id="candidate-project" name="project_id"></select>
              </label>
              <label>
                Position (optional)
                <select id="candidate-position" name="position_id"></select>
              </label>
              <label>
                Status
                <select name="status">
                  <option value="new">New</option>
                  <option value="screening">Screening</option>
                  <option value="interviewing">Interviewing</option>
                  <option value="offer">Offer</option>
                  <option value="hired">Hired</option>
                  <option value="rejected">Rejected</option>
                  <option value="withdrawn">Withdrawn</option>
                </select>
              </label>
              <button type="submit">Save candidate</button>
            </form>
          </section>
        </div>

        <section class="subpanel" id="linkedin-xray-panel">
          <div>
            <h3>LinkedIn X-Ray search</h3>
            <p class="muted" style="margin-top: 4px;">
              Launch boolean searches against LinkedIn from your sourcing playbook. Results will populate automatically once the AI agent finishes gathering profiles.
            </p>
          </div>
          <form id="linkedin-xray-form" autocomplete="off">
            <label>
              Project
              <select id="linkedin-project" name="project_id" required></select>
            </label>
            <label>
              Search query
              <input name="search_query" type="text" placeholder="\"Revenue Operations\" SaaS enterprise" required />
            </label>
            <label>
              Locations (comma separated)
              <input name="locations" type="text" placeholder="San Francisco, Remote" />
            </label>
            <label>
              Titles to include (comma separated)
              <input name="titles" type="text" placeholder="Head of Revenue Operations, VP Revenue" />
            </label>
            <label>
              Must include keywords (one per line)
              <textarea name="must_include" placeholder="GTM analytics\nSalesforce"></textarea>
            </label>
            <label>
              Must exclude keywords (one per line)
              <textarea name="must_exclude" placeholder="Agency recruiter\nContract"></textarea>
            </label>
            <label>
              Result limit
              <input name="result_limit" type="number" min="1" max="50" value="25" />
            </label>
            <button type="submit">Start LinkedIn search</button>
            <p class="muted">Search criteria are saved inside the AI job and replayed through the async worker queue.</p>
          </form>
          <div>
            <h4>Recent LinkedIn searches</h4>
            <ul class="item-list" id="linkedin-xray-jobs"></ul>
          </div>
        </section>
      </section>
    </main>

    <script>
      const state = {
        token: window.localStorage.getItem("recruitproToken"),
        user: null,
        projects: [],
        positions: [],
        candidates: [],
        linkedinJobs: [],
      };

      let activitySource = null;
      const linkedinPolls = new Map();

      const messagesEl = document.getElementById("messages");
      const authPanel = document.getElementById("auth-panel");
      const appPanel = document.getElementById("app-panel");
      const workspaceUser = document.getElementById("workspace-user");
      const workspaceRole = document.getElementById("workspace-role");
      const statProjects = document.getElementById("stat-projects");
      const statPositions = document.getElementById("stat-positions");
      const statOpenPositions = document.getElementById("stat-open-positions");
      const statCandidates = document.getElementById("stat-candidates");
      const projectsList = document.getElementById("projects-list");
      const positionsList = document.getElementById("positions-list");
      const candidatesList = document.getElementById("candidates-list");
      const positionProjectSelect = document.getElementById("position-project");
      const candidateProjectSelect = document.getElementById("candidate-project");
      const candidatePositionSelect = document.getElementById("candidate-position");
      const documentProjectSelect = document.getElementById("document-project");
      const documentUploadForm = document.getElementById("document-upload-form");
      const documentFileInput = document.getElementById("document-file");
      const linkedinForm = document.getElementById("linkedin-xray-form");
      const linkedinProjectSelect = document.getElementById("linkedin-project");
      const linkedinJobsList = document.getElementById("linkedin-xray-jobs");
      const refreshButton = document.getElementById("refresh-button");
      const logoutButton = document.getElementById("logout-button");

      function setMessage(text, variant = "info") {
        if (!text) {
          messagesEl.dataset.state = "hidden";
          messagesEl.textContent = "";
          return;
        }
        messagesEl.dataset.state = "visible";
        messagesEl.dataset.variant = variant;
        messagesEl.textContent = text;
      }

      function closeActivityStream() {
        if (activitySource) {
          activitySource.close();
          activitySource = null;
        }
      }

      function handleActivityEvent(event) {
        let payload = null;
        if (event.data) {
          try {
            payload = JSON.parse(event.data);
          } catch (error) {
            console.warn("Unable to parse activity payload", error);
          }
        }
        if (payload && payload.message) {
          setMessage(payload.message, "info");
        }
        if (state.token) {
          loadWorkspace(false);
        }
      }

      function handleJobEvent(event) {
        let payload = null;
        if (event.data) {
          try {
            payload = JSON.parse(event.data);
          } catch (error) {
            console.warn("Unable to parse job payload", error);
          }
        }
        if (!payload) {
          return;
        }
        const jobId = payload.job_id ? `Job ${payload.job_id}` : "AI job";
        const status = payload.status || "updated";
        let variant = "info";
        if (status === "completed") {
          variant = "success";
        } else if (status === "failed") {
          variant = "error";
        }
        const detail = payload.error ? ` (${payload.error})` : "";
        setMessage(`${jobId} ${status}${detail}.`, variant);
        if (payload.job_id && isTrackedLinkedInJob(payload.job_id)) {
          upsertLinkedInJob({
            job_id: payload.job_id,
            status: payload.status,
            error: payload.error,
            updated_at: new Date().toISOString(),
          });
          renderLinkedInJobs();
          scheduleLinkedInJobPoll(payload.job_id, true);
        }
      }

      function openActivityStream() {
        if (!state.token) {
          closeActivityStream();
          return;
        }
        const streamUrl = new URL("/api/activity/stream", window.location.origin);
        streamUrl.searchParams.set("token", state.token);
        closeActivityStream();
        const source = new EventSource(streamUrl.toString());
        source.addEventListener("activity", handleActivityEvent);
        source.addEventListener("job", handleJobEvent);
        source.onerror = () => {
          // Allow the browser to retry automatically.
        };
        activitySource = source;
      }

      function ensureActivityStream() {
        if (!state.token) {
          closeActivityStream();
          return;
        }
        if (!activitySource) {
          openActivityStream();
        }
      }

      function clearLinkedInPolls() {
        linkedinPolls.forEach((timeout) => window.clearTimeout(timeout));
        linkedinPolls.clear();
      }

      function isTrackedLinkedInJob(jobId) {
        if (!jobId) {
          return false;
        }
        return state.linkedinJobs.some((job) => job.job_id === jobId);
      }

      function upsertLinkedInJob(partial) {
        if (!partial || !partial.job_id) {
          return;
        }
        const index = state.linkedinJobs.findIndex((job) => job.job_id === partial.job_id);
        const existing = index >= 0 ? state.linkedinJobs[index] : null;
        const merged = {
          job_id: partial.job_id,
          status: partial.status || (existing ? existing.status : "queued"),
          progress:
            partial.progress !== undefined && partial.progress !== null
              ? partial.progress
              : existing && existing.progress !== undefined
              ? existing.progress
              : null,
          found_count:
            partial.found_count !== undefined && partial.found_count !== null
              ? partial.found_count
              : existing && existing.found_count !== undefined
              ? existing.found_count
              : null,
          results: Array.isArray(partial.results)
            ? partial.results
            : existing && Array.isArray(existing.results)
            ? existing.results
            : [],
          error:
            partial.error !== undefined
              ? partial.error
              : existing && existing.error !== undefined
              ? existing.error
              : null,
          search_query:
            partial.search_query !== undefined
              ? partial.search_query
              : existing && existing.search_query !== undefined
              ? existing.search_query
              : "",
          project_id:
            partial.project_id !== undefined
              ? partial.project_id
              : existing && existing.project_id !== undefined
              ? existing.project_id
              : null,
          locations:
            partial.locations !== undefined
              ? partial.locations || []
              : existing && existing.locations !== undefined
              ? existing.locations
              : [],
          titles:
            partial.titles !== undefined
              ? partial.titles || []
              : existing && existing.titles !== undefined
              ? existing.titles
              : [],
          must_include:
            partial.must_include !== undefined
              ? partial.must_include || []
              : existing && existing.must_include !== undefined
              ? existing.must_include
              : [],
          must_exclude:
            partial.must_exclude !== undefined
              ? partial.must_exclude || []
              : existing && existing.must_exclude !== undefined
              ? existing.must_exclude
              : [],
          result_limit:
            partial.result_limit !== undefined
              ? partial.result_limit
              : existing && existing.result_limit !== undefined
              ? existing.result_limit
              : null,
          updated_at: partial.updated_at || new Date().toISOString(),
        };
        if (index >= 0) {
          state.linkedinJobs[index] = merged;
        } else {
          state.linkedinJobs.unshift(merged);
        }
      }

      function renderLinkedInJobs() {
        if (!linkedinJobsList) {
          return;
        }
        linkedinJobsList.innerHTML = "";
        if (state.linkedinJobs.length === 0) {
          const empty = document.createElement("li");
          empty.className = "empty-state";
          empty.textContent = "Start a LinkedIn X-Ray search to see candidate leads.";
          linkedinJobsList.appendChild(empty);
          return;
        }

        state.linkedinJobs.forEach((job) => {
          const item = document.createElement("li");
          item.className = "item-card";

          const title = document.createElement("h4");
          title.textContent = job.search_query ? job.search_query : `Job ${job.job_id}`;
          item.appendChild(title);

          const jobIdLine = document.createElement("p");
          jobIdLine.className = "muted";
          jobIdLine.textContent = `Job ID: ${job.job_id}`;
          item.appendChild(jobIdLine);

          if (job.project_id) {
            const project = projectLookup(job.project_id);
            if (project) {
              const projectLine = document.createElement("p");
              projectLine.className = "muted";
              projectLine.textContent = `Project: ${project.name}`;
              item.appendChild(projectLine);
            }
          }

          const statusLine = document.createElement("p");
          const statusParts = [`Status: ${job.status || "queued"}`];
          if (job.progress !== null && job.progress !== undefined) {
            statusParts.push(`Progress: ${job.progress}%`);
          }
          if (job.found_count !== null && job.found_count !== undefined) {
            statusParts.push(`Profiles: ${job.found_count}`);
          }
          statusLine.textContent = statusParts.join(" â€¢ ");
          if (job.status === "completed") {
            statusLine.className = "text-success";
          } else if (job.status === "failed") {
            statusLine.className = "text-error";
          } else {
            statusLine.className = "muted";
          }
          item.appendChild(statusLine);

          if (job.error) {
            const errorLine = document.createElement("p");
            errorLine.className = "text-error";
            errorLine.textContent = job.error;
            item.appendChild(errorLine);
          }

          if (job.updated_at) {
            const updated = new Date(job.updated_at);
            if (!Number.isNaN(updated.getTime())) {
              const updatedLine = document.createElement("p");
              updatedLine.className = "muted";
              updatedLine.textContent = `Updated ${updated.toLocaleTimeString()}`;
              item.appendChild(updatedLine);
            }
          }

          if (job.locations && job.locations.length) {
            const locationsLine = document.createElement("p");
            locationsLine.className = "muted";
            locationsLine.textContent = `Locations: ${job.locations.join(", ")}`;
            item.appendChild(locationsLine);
          }

          if (job.titles && job.titles.length) {
            const titlesLine = document.createElement("p");
            titlesLine.className = "muted";
            titlesLine.textContent = `Titles: ${job.titles.join(", ")}`;
            item.appendChild(titlesLine);
          }

          if (job.must_include && job.must_include.length) {
            const includeLine = document.createElement("p");
            includeLine.className = "muted";
            includeLine.textContent = `Must include: ${job.must_include.join(", ")}`;
            item.appendChild(includeLine);
          }

          if (job.must_exclude && job.must_exclude.length) {
            const excludeLine = document.createElement("p");
            excludeLine.className = "muted";
            excludeLine.textContent = `Must exclude: ${job.must_exclude.join(", ")}`;
            item.appendChild(excludeLine);
          }

          if (job.result_limit) {
            const limitLine = document.createElement("p");
            limitLine.className = "muted";
            limitLine.textContent = `Requested results: ${job.result_limit}`;
            item.appendChild(limitLine);
          }

          if (Array.isArray(job.results) && job.results.length) {
            const resultsList = document.createElement("div");
            resultsList.className = "result-list";
            job.results.forEach((result, index) => {
              const card = document.createElement("div");
              card.className = "result-card";

              const heading = document.createElement("h5");
              heading.textContent = result.name || result.title || `Profile ${index + 1}`;
              card.appendChild(heading);

              const metaParts = [];
              if (result.title) metaParts.push(result.title);
              if (result.location) metaParts.push(result.location);
              if (result.platform) metaParts.push(result.platform);
              if (metaParts.length) {
                const meta = document.createElement("p");
                meta.className = "muted";
                meta.textContent = metaParts.join(" â€¢ ");
                card.appendChild(meta);
              }

              if (result.summary) {
                const summary = document.createElement("p");
                summary.textContent = result.summary;
                card.appendChild(summary);
              }

              if (result.profile_url) {
                const link = document.createElement("a");
                link.href = result.profile_url;
                link.textContent = "Open profile";
                link.target = "_blank";
                link.rel = "noreferrer";
                card.appendChild(link);
              }

              resultsList.appendChild(card);
            });
            item.appendChild(resultsList);
          } else if (job.status === "completed") {
            const emptyResults = document.createElement("p");
            emptyResults.className = "muted";
            emptyResults.textContent = "No profiles returned for this search.";
            item.appendChild(emptyResults);
          }

          linkedinJobsList.appendChild(item);
        });
      }

      async function runLinkedInJobPoll(jobId) {
        if (!jobId || !isTrackedLinkedInJob(jobId)) {
          return;
        }
        if (linkedinPolls.has(jobId)) {
          linkedinPolls.delete(jobId);
        }
        try {
          const job = await apiFetch(`/api/sourcing/jobs/${encodeURIComponent(jobId)}`);
          if (!job || !isTrackedLinkedInJob(jobId)) {
            return;
          }
          upsertLinkedInJob({
            job_id: job.job_id,
            status: job.status,
            progress: job.progress,
            found_count: job.found_count,
            results: job.results,
            updated_at: new Date().toISOString(),
          });
          renderLinkedInJobs();
          if (job.status && !["completed", "failed", "cancelled"].includes(job.status)) {
            scheduleLinkedInJobPoll(jobId);
          }
        } catch (error) {
          if (error && typeof error.message === "string" && error.message.includes("404")) {
            scheduleLinkedInJobPoll(jobId);
            return;
          }
          console.error("LinkedIn X-Ray polling failed", error);
        }
      }

      function scheduleLinkedInJobPoll(jobId, immediate = false) {
        if (!jobId || !isTrackedLinkedInJob(jobId)) {
          return;
        }
        if (linkedinPolls.has(jobId)) {
          window.clearTimeout(linkedinPolls.get(jobId));
          linkedinPolls.delete(jobId);
        }
        if (immediate) {
          runLinkedInJobPoll(jobId);
          return;
        }
        const timeout = window.setTimeout(() => runLinkedInJobPoll(jobId), 4000);
        linkedinPolls.set(jobId, timeout);
      }

      function toList(value) {
        return value
          .split(",")
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function toLines(value) {
        return value
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean);
      }

      async function apiFetch(path, options = {}) {
        const config = { method: "GET", headers: { Accept: "application/json" }, ...options };
        config.headers = new Headers(config.headers);

        if (state.token) {
          config.headers.set("Authorization", `Bearer ${state.token}`);
        }

        const response = await fetch(path, config);
        const text = await response.text();
        let data = null;
        if (text) {
          try {
            data = JSON.parse(text);
          } catch (error) {
            data = null;
          }
        }

        if (!response.ok) {
          if (response.status === 401) {
            handleLogout(false);
          }
          const detail = data && (data.detail || data.message);
          throw new Error(detail || `Request failed with status ${response.status}`);
        }

        return data;
      }

      async function registerUser(event) {
        event.preventDefault();
        const form = event.currentTarget;
        const formData = new FormData(form);
        const payload = {
          name: formData.get("name").trim(),
          email: formData.get("email").trim().toLowerCase(),
          password: formData.get("password"),
          role: formData.get("role"),
        };

        try {
          form.querySelector("button[type=submit]").disabled = true;
          const response = await fetch("/api/auth/register", {
            method: "POST",
            headers: { "Content-Type": "application/json", Accept: "application/json" },
            body: JSON.stringify(payload),
          });

          const data = await response.json().catch(() => null);
          if (!response.ok) {
            throw new Error((data && (data.detail || data.message)) || "Registration failed");
          }

          form.reset();
          setMessage("Account created. You can now sign in.", "success");
        } catch (error) {
          setMessage(error.message, "error");
        } finally {
          form.querySelector("button[type=submit]").disabled = false;
        }
      }

      async function loginUser(event) {
        event.preventDefault();
        const form = event.currentTarget;
        const formData = new FormData(form);
        const payload = new URLSearchParams();
        payload.set("username", formData.get("email").trim().toLowerCase());
        payload.set("password", formData.get("password"));

        try {
          form.querySelector("button[type=submit]").disabled = true;
          const response = await fetch("/api/auth/login", {
            method: "POST",
            headers: { Accept: "application/json" },
            body: payload,
          });
          const data = await response.json().catch(() => null);
          if (!response.ok) {
            throw new Error((data && (data.detail || data.message)) || "Login failed");
          }

          state.token = data.access_token;
          window.localStorage.setItem("recruitproToken", state.token);
          form.reset();
          setMessage("Signed in successfully.", "success");
          await loadWorkspace(false);
        } catch (error) {
          setMessage(error.message, "error");
        } finally {
          form.querySelector("button[type=submit]").disabled = false;
        }
      }

      function handleLogout(showNotice = true) {
        closeActivityStream();
        clearLinkedInPolls();
        state.token = null;
        state.user = null;
        state.projects = [];
        state.positions = [];
        state.candidates = [];
        state.linkedinJobs = [];
        window.localStorage.removeItem("recruitproToken");
        authPanel.classList.remove("hidden");
        appPanel.classList.add("hidden");
        projectsList.innerHTML = "";
        positionsList.innerHTML = "";
        candidatesList.innerHTML = "";
        if (linkedinJobsList) {
          linkedinJobsList.innerHTML = "";
        }
        renderStats();
        refreshProjectOptions();
        if (showNotice) {
          setMessage("You have been signed out.", "info");
        } else {
          setMessage("", "info");
        }
      }

      function renderStats() {
        statProjects.textContent = state.projects.length;
        statPositions.textContent = state.positions.length;
        statOpenPositions.textContent = state.positions.filter((item) => item.status === "open").length;
        statCandidates.textContent = state.candidates.length;
      }

      function renderProjects() {
        projectsList.innerHTML = "";
        if (state.projects.length === 0) {
          const empty = document.createElement("li");
          empty.className = "empty-state";
          empty.textContent = "No projects yet. Create one to get started.";
          projectsList.appendChild(empty);
          return;
        }

        state.projects.forEach((project) => {
          const item = document.createElement("li");
          item.className = "item-card";

          const title = document.createElement("h4");
          title.textContent = project.name;
          item.appendChild(title);

          const subtitle = document.createElement("p");
          subtitle.className = "muted";
          const client = project.client ? `Client: ${project.client}` : "No client assigned";
          subtitle.textContent = `${client} â€¢ Status: ${project.status}`;
          item.appendChild(subtitle);

          if (project.summary) {
            const summary = document.createElement("p");
            summary.textContent = project.summary;
            item.appendChild(summary);
          }

          const tags = [];
          if (project.tags && project.tags.length) {
            tags.push(`Tags: ${project.tags.join(", ")}`);
          }
          if (project.team_members && project.team_members.length) {
            tags.push(`Team: ${project.team_members.join(", ")}`);
          }
          if (tags.length) {
            const meta = document.createElement("p");
            meta.className = "muted";
            meta.textContent = tags.join(" â€¢ ");
            item.appendChild(meta);
          }

          const hires = document.createElement("p");
          hires.className = "muted";
          const target = project.target_hires ?? 0;
          hires.textContent = `Hires: ${project.hires_count ?? 0} / ${target}`;
          item.appendChild(hires);

          projectsList.appendChild(item);
        });
      }

      function projectLookup(projectId) {
        return state.projects.find((project) => project.project_id === projectId);
      }

      function positionLookup(positionId) {
        return state.positions.find((position) => position.position_id === positionId);
      }

      function renderPositions() {
        positionsList.innerHTML = "";
        if (state.positions.length === 0) {
          const empty = document.createElement("li");
          empty.className = "empty-state";
          empty.textContent = "No positions yet. Link a role to a project to begin tracking.";
          positionsList.appendChild(empty);
          return;
        }

        state.positions.forEach((position) => {
          const item = document.createElement("li");
          item.className = "item-card";

          const title = document.createElement("h4");
          title.textContent = position.title;
          item.appendChild(title);

          const project = projectLookup(position.project_id);
          const details = document.createElement("p");
          details.className = "muted";
          const projectName = project ? project.name : "Unassigned";
          details.textContent = `${projectName} â€¢ Status: ${position.status}`;
          item.appendChild(details);

          if (position.location) {
            const location = document.createElement("p");
            location.textContent = `Location: ${position.location}`;
            item.appendChild(location);
          }

          const openings = document.createElement("p");
          openings.className = "muted";
          openings.textContent = `Openings: ${position.openings ?? 0} â€¢ Applicants: ${position.applicants_count ?? 0}`;
          item.appendChild(openings);

          positionsList.appendChild(item);
        });
      }

      function renderCandidates() {
        candidatesList.innerHTML = "";
        if (state.candidates.length === 0) {
          const empty = document.createElement("li");
          empty.className = "empty-state";
          empty.textContent = "No candidates recorded. Add talent to start building your pipeline.";
          candidatesList.appendChild(empty);
          return;
        }

        state.candidates.forEach((candidate) => {
          const item = document.createElement("li");
          item.className = "item-card";

          const title = document.createElement("h4");
          title.textContent = candidate.name;
          item.appendChild(title);

          const meta = document.createElement("p");
          meta.className = "muted";
          const source = candidate.source ? `Source: ${candidate.source}` : "";
          const status = `Status: ${candidate.status}`;
          meta.textContent = [source, status].filter(Boolean).join(" â€¢ ");
          item.appendChild(meta);

          const project = projectLookup(candidate.project_id);
          const position = positionLookup(candidate.position_id);
          if (project || position) {
            const assignment = document.createElement("p");
            assignment.className = "muted";
            const parts = [];
            if (project) {
              parts.push(`Project: ${project.name}`);
            }
            if (position) {
              parts.push(`Role: ${position.title}`);
            }
            assignment.textContent = parts.join(" â€¢ ");
            item.appendChild(assignment);
          }

          const link = document.createElement("a");
          link.textContent = "Open profile";
          link.href = `/candidate-profile?candidate_id=${encodeURIComponent(candidate.candidate_id)}${
            state.token ? `&token=${encodeURIComponent(state.token)}` : ""
          }`;
          link.target = "_blank";
          link.rel = "noreferrer";
          item.appendChild(link);

          candidatesList.appendChild(item);
        });
      }

      function refreshProjectOptions() {
        const selects = [
          { element: positionProjectSelect, placeholder: "Select a project" },
          { element: candidateProjectSelect, placeholder: "No project" },
          {
            element: documentProjectSelect,
            placeholder: state.projects.length ? "Choose a project" : "No projects available",
          },
          {
            element: linkedinProjectSelect,
            placeholder: state.projects.length ? "Choose a project" : "No projects available",
          },
        ];
        selects.forEach(({ element, placeholder }) => {
          if (!element) return;
          const current = element.value;
          element.innerHTML = "";
          const option = document.createElement("option");
          option.value = "";
          option.textContent = placeholder;
          element.appendChild(option);
          state.projects.forEach((project) => {
            const projectOption = document.createElement("option");
            projectOption.value = project.project_id;
            projectOption.textContent = project.name;
            element.appendChild(projectOption);
          });
          if (current && state.projects.some((project) => project.project_id === current)) {
            element.value = current;
          }
        });

        if (documentProjectSelect) {
          documentProjectSelect.disabled = state.projects.length === 0;
        }
        if (documentUploadForm) {
          const submitButton = documentUploadForm.querySelector("button[type=submit]");
          if (submitButton) {
            submitButton.disabled = state.projects.length === 0;
          }
        }

        if (linkedinProjectSelect) {
          linkedinProjectSelect.disabled = state.projects.length === 0;
        }
        if (linkedinForm) {
          const submitButton = linkedinForm.querySelector("button[type=submit]");
          if (submitButton) {
            submitButton.disabled = state.projects.length === 0;
          }
        }

        refreshCandidatePositionOptions();
      }

      function refreshCandidatePositionOptions() {
        const selectedProjectId = candidateProjectSelect.value;
        const relevantPositions = selectedProjectId
          ? state.positions.filter((position) => position.project_id === selectedProjectId)
          : state.positions;

        const current = candidatePositionSelect.value;
        candidatePositionSelect.innerHTML = "";
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = relevantPositions.length ? "No position" : "No positions available";
        candidatePositionSelect.appendChild(placeholder);

        relevantPositions.forEach((position) => {
          const option = document.createElement("option");
          option.value = position.position_id;
          option.textContent = `${position.title} (${projectLookup(position.project_id)?.name || "Unassigned"})`;
          candidatePositionSelect.appendChild(option);
        });

        if (current && relevantPositions.some((position) => position.position_id === current)) {
          candidatePositionSelect.value = current;
        }
      }

      function renderWorkspace() {
        if (!state.user) {
          workspaceUser.textContent = "Signed in as â€”";
          workspaceRole.textContent = "";
          workspaceRole.classList.add("hidden");
        } else {
          workspaceUser.textContent = `Signed in as ${state.user.name} (${state.user.email})`;
          workspaceRole.textContent = state.user.role === "admin" ? "Admin" : "Recruiter";
          workspaceRole.classList.remove("hidden");
        }

        renderStats();
        renderProjects();
        renderPositions();
        renderCandidates();
        renderLinkedInJobs();
        refreshProjectOptions();
      }

      async function loadWorkspace(showNotice = false) {
        if (!state.token) {
          handleLogout(false);
          return;
        }

        try {
          const [user, projects, positions, candidates] = await Promise.all([
            apiFetch("/api/user"),
            apiFetch("/api/projects"),
            apiFetch("/api/positions"),
            apiFetch("/api/candidates"),
          ]);

          state.user = user;
          state.projects = Array.isArray(projects) ? projects : [];
          state.positions = Array.isArray(positions) ? positions : [];
          state.candidates = Array.isArray(candidates) ? candidates : [];

          authPanel.classList.add("hidden");
          appPanel.classList.remove("hidden");
          renderWorkspace();
          ensureActivityStream();
          if (showNotice) {
            setMessage("Workspace loaded.", "success");
          }
        } catch (error) {
          setMessage(error.message, "error");
        }
      }

      async function uploadProjectDocument(event) {
        event.preventDefault();
        if (!state.token) {
          setMessage("Please sign in first.", "error");
          return;
        }

        if (!documentProjectSelect || !documentFileInput) {
          setMessage("Document upload form is unavailable.", "error");
          return;
        }

        const projectId = documentProjectSelect.value;
        const file = documentFileInput.files && documentFileInput.files[0];

        if (!projectId) {
          setMessage("Select a project before uploading a document.", "error");
          return;
        }

        if (!file) {
          setMessage("Choose a file to upload.", "error");
          return;
        }

        const submitButton = documentUploadForm ? documentUploadForm.querySelector("button[type=submit]") : null;

        try {
          if (submitButton) {
            submitButton.disabled = true;
          }
          const formData = new FormData();
          formData.append("file", file);
          formData.append("filename", file.name);
          formData.append("mime_type", file.type || "application/octet-stream");
          formData.append("scope", "project");
          formData.append("scope_id", projectId);

          await apiFetch("/api/documents/upload", {
            method: "POST",
            body: formData,
          });

          if (documentUploadForm) {
            documentUploadForm.reset();
          }
          documentProjectSelect.value = projectId;
          setMessage(`Uploaded ${file.name} for the project.`, "success");
        } catch (error) {
          setMessage(error.message, "error");
        } finally {
          if (submitButton) {
            submitButton.disabled = state.projects.length === 0;
          }
        }
      }

      async function startLinkedInXray(event) {
        event.preventDefault();
        if (!state.token) {
          setMessage("Please sign in first.", "error");
          return;
        }

        if (!linkedinForm) {
          setMessage("LinkedIn search form is unavailable.", "error");
          return;
        }

        const form = event.currentTarget;
        const formData = new FormData(form);
        const projectId = formData.get("project_id");
        const searchQuery = (formData.get("search_query") || "").toString().trim();

        if (!projectId) {
          setMessage("Select a project before starting a LinkedIn search.", "error");
          return;
        }

        if (!searchQuery) {
          setMessage("Enter a search query for LinkedIn X-Ray.", "error");
          return;
        }

        const payload = { project_id: projectId, search_query: searchQuery };
        const locationsRaw = (formData.get("locations") || "").toString().trim();
        if (locationsRaw) {
          payload.locations = toList(locationsRaw);
        }
        const titlesRaw = (formData.get("titles") || "").toString().trim();
        if (titlesRaw) {
          payload.titles = toList(titlesRaw);
        }
        const includeRaw = (formData.get("must_include") || "").toString().trim();
        if (includeRaw) {
          payload.must_include = toLines(includeRaw);
        }
        const excludeRaw = (formData.get("must_exclude") || "").toString().trim();
        if (excludeRaw) {
          payload.must_exclude = toLines(excludeRaw);
        }
        const limitRaw = (formData.get("result_limit") || "").toString().trim();
        if (limitRaw) {
          const limitNumber = Number.parseInt(limitRaw, 10);
          if (!Number.isNaN(limitNumber)) {
            payload.result_limit = limitNumber;
          }
        }

        const submitButton = form.querySelector("button[type=submit]");

        try {
          if (submitButton) {
            submitButton.disabled = true;
          }
          const job = await apiFetch("/api/sourcing/linkedin-xray/start", {
            method: "POST",
            headers: { "Content-Type": "application/json", Accept: "application/json" },
            body: JSON.stringify(payload),
          });

          if (job && job.job_id) {
            upsertLinkedInJob({
              job_id: job.job_id,
              status: job.status,
              search_query: searchQuery,
              project_id: projectId,
              locations: payload.locations,
              titles: payload.titles,
              must_include: payload.must_include,
              must_exclude: payload.must_exclude,
              result_limit: payload.result_limit,
              updated_at: new Date().toISOString(),
            });
            renderLinkedInJobs();
            scheduleLinkedInJobPoll(job.job_id, true);
            setMessage(`LinkedIn X-Ray job ${job.job_id} started.`, "success");
          } else {
            setMessage("LinkedIn X-Ray search started.", "success");
          }

          const previousProject = projectId;
          form.reset();
          if (linkedinProjectSelect && previousProject) {
            linkedinProjectSelect.value = previousProject;
          }
        } catch (error) {
          setMessage(error.message, "error");
        } finally {
          if (submitButton) {
            submitButton.disabled = state.projects.length === 0;
          }
        }
      }

      async function createProject(event) {
        event.preventDefault();
        if (!state.token) {
          setMessage("Please sign in first.", "error");
          return;
        }

        const form = event.currentTarget;
        const formData = new FormData(form);
        const payload = {
          name: formData.get("name").trim(),
        };
        const client = formData.get("client").trim();
        const location = formData.get("location_region").trim();
        const summary = formData.get("summary").trim();
        const tagsValue = formData.get("tags").trim();
        const teamMembersValue = formData.get("team_members").trim();
        const target = formData.get("target_hires").trim();

        if (client) payload.client = client;
        if (location) payload.location_region = location;
        if (summary) payload.summary = summary;
        if (tagsValue) payload.tags = toList(tagsValue);
        if (teamMembersValue) payload.team_members = toList(teamMembersValue);
        if (target) {
          const targetNumber = Number.parseInt(target, 10);
          if (!Number.isNaN(targetNumber)) {
            payload.target_hires = targetNumber;
          }
        }

        try {
          form.querySelector("button[type=submit]").disabled = true;
          await apiFetch("/api/projects", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          form.reset();
          await loadWorkspace(false);
          setMessage("Project created successfully.", "success");
        } catch (error) {
          setMessage(error.message, "error");
        } finally {
          form.querySelector("button[type=submit]").disabled = false;
        }
      }

      async function createPosition(event) {
        event.preventDefault();
        if (!state.token) {
          setMessage("Please sign in first.", "error");
          return;
        }

        const form = event.currentTarget;
        const formData = new FormData(form);
        const payload = {
          project_id: formData.get("project_id"),
          title: formData.get("title").trim(),
        };
        const department = formData.get("department").trim();
        const location = formData.get("location").trim();
        const status = formData.get("status");
        const openings = formData.get("openings").trim();
        const responsibilities = formData.get("responsibilities").trim();
        const requirements = formData.get("requirements").trim();

        if (!payload.project_id) {
          setMessage("Select a project before creating a position.", "error");
          return;
        }

        if (department) payload.department = department;
        if (location) payload.location = location;
        if (status) payload.status = status;
        if (openings) {
          const openingsNumber = Number.parseInt(openings, 10);
          if (!Number.isNaN(openingsNumber)) {
            payload.openings = openingsNumber;
          }
        }
        if (responsibilities) payload.responsibilities = toLines(responsibilities);
        if (requirements) payload.requirements = toLines(requirements);

        try {
          form.querySelector("button[type=submit]").disabled = true;
          await apiFetch("/api/positions", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          form.reset();
          await loadWorkspace(false);
          setMessage("Position created successfully.", "success");
        } catch (error) {
          setMessage(error.message, "error");
        } finally {
          form.querySelector("button[type=submit]").disabled = false;
        }
      }

      async function createCandidate(event) {
        event.preventDefault();
        if (!state.token) {
          setMessage("Please sign in first.", "error");
          return;
        }

        const form = event.currentTarget;
        const formData = new FormData(form);
        const payload = {
          name: formData.get("name").trim(),
          source: formData.get("source").trim(),
          status: formData.get("status"),
        };
        const email = formData.get("email").trim();
        const projectId = formData.get("project_id");
        const positionId = formData.get("position_id");

        if (email) payload.email = email;
        if (projectId) payload.project_id = projectId;
        if (positionId) payload.position_id = positionId;

        try {
          form.querySelector("button[type=submit]").disabled = true;
          await apiFetch("/api/candidates", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          form.reset();
          refreshCandidatePositionOptions();
          await loadWorkspace(false);
          setMessage("Candidate added successfully.", "success");
        } catch (error) {
          setMessage(error.message, "error");
        } finally {
          form.querySelector("button[type=submit]").disabled = false;
        }
      }

      document.getElementById("register-form").addEventListener("submit", registerUser);
      document.getElementById("login-form").addEventListener("submit", loginUser);
      document.getElementById("project-form").addEventListener("submit", createProject);
      if (documentUploadForm) {
        documentUploadForm.addEventListener("submit", uploadProjectDocument);
      }
      if (linkedinForm) {
        linkedinForm.addEventListener("submit", startLinkedInXray);
      }
      document.getElementById("position-form").addEventListener("submit", createPosition);
      document.getElementById("candidate-form").addEventListener("submit", createCandidate);
      candidateProjectSelect.addEventListener("change", refreshCandidatePositionOptions);
      refreshButton.addEventListener("click", () => {
        if (!state.token) {
          setMessage("Sign in to refresh workspace data.", "error");
          return;
        }
        loadWorkspace(true);
      });
      logoutButton.addEventListener("click", () => handleLogout(true));
      window.addEventListener("beforeunload", () => {
        closeActivityStream();
        clearLinkedInPolls();
      });

      if (state.token) {
        loadWorkspace(false);
      }
    </script>
  </body>
</html>
